#!/usr/bin/env python2
# -*- coding: utf-8 -*-

# For Fig 1 and 2 in paper (https://arxiv.org/pdf/1601.06748.pdf):
# Set static V = 0.93 and gp = 5, then calculate min and max buf based on those 
# (paper also assumes static bitrates/sizes, so min/max buf is static too for these figures).
# The Puffer and dash.js implementations do the opposite (static min/max buf => dynamic V and gp), 
# but this is useful to reproduce Fig 1 and 2 (and understand their units...)

import numpy as np
import matplotlib.pyplot as plt

# Mbps
bitrates = [
6.000,
2.962,
1.427,
0.688,
0.331]

# Mb
sizes = [
18.00,
8.886,
4.281,
2.064,
0.993]

def utility(m):
    return np.log(sizes[m] / sizes[-1])

# seconds
p = 3
# The paper's static V and gp used for Fig 1/2
# chunks (kind of?)
V_static = 0.93
gp_static = 5
MIN_BUF_SZ_S = p * V_static * (sizes[-2] * (utility(-1) + gp_static) - sizes[-1] * (utility(-2) + gp_static)) / \
             (sizes[-2] - sizes[-1]) # should be ~12 for paper
            
MAX_BUF_SZ_S = p * V_static * (utility(0) + gp_static) # should be ~22 for paper


# Q: number of chunks
def objective(Q, m):
    return (V * (utility(m) + gp) - Q) / (sizes[m] * 10 ** 6) # plot S in bits not Mb

def plot_min_max_buf(ax):
    ax.axvline(x = MIN_BUF_SZ_S, linestyle='dotted', color='gray')
    ax.axvline(x = MAX_BUF_SZ_S, linestyle='dotted', color='gray')

def plot_objective(V, gp, ax):
    Qp = np.linspace(0, 25, num=10)
    ax.set_ylim(0, 1 * 10 ** -6)
    for m in range(len(bitrates)):
        ax.plot(Qp, objective(Qp / p, m), label=bitrates[m])

    plot_min_max_buf(ax)
    ax.set_xlabel("Q (sec)")
    ax.set_ylabel("Objective value")
    ax.legend()
    ax.set_title("V = " + str(V) + ", gp = " + str(gp))

def choose_bitrate(Q):
    # For Puffer, this happens in the media server
    full_buf_s = p * V * (utility(0) + gp)
    assert(full_buf_s == MAX_BUF_SZ_S)
    if Q * p > full_buf_s:
        return 0
    objectives = [objective(Q, m) for m in range(len(bitrates))]
    chosen_idx = objectives.index(max(objectives))
    return bitrates[chosen_idx]
    
def plot_decision(V, gp, ax):
    Qp = np.linspace(0, 25, num=100000) # approx stepwise
    choices = [choose_bitrate(qp / p) for qp in Qp]    
    
    plot_min_max_buf(ax)
    ax.plot(Qp, choices)
    ax.set_xlabel("Q (sec)")
    ax.set_ylabel("Chosen bitrate (Mbps)")  
    ax.set_title("V = " + str(V) + ", gp = " + str(gp))

def calculate_parameters(min_buf_s, max_buf_s):    
    # code the math 
    min_buf_chunks = min_buf_s / p
    max_buf_chunks = max_buf_s / p
    size_delta = sizes[-2] - sizes[-1] 
    
    gp = (
            max_buf_chunks * ( sizes[-2] * utility(-1) - sizes[-1] * utility(-2) ) - \
                utility(0) * min_buf_chunks * size_delta
         ) / \
         (
            (min_buf_chunks - max_buf_chunks) * size_delta
         )

    V = max_buf_chunks / (utility(0) + gp)
    # TODO: fix nonsense scoping
    return (V, gp)

# 1. M*_BUF_SZ_S: static like they are in Puffer (here calculated using static V and gp, 
# which we're now trying to recover)
    
# 2. Using min/max buf and algebra, calculate V and gp and hopefully they're 0.93 and 5
V, gp = calculate_parameters(MIN_BUF_SZ_S, MAX_BUF_SZ_S)
print("Recovered V " + str(V) + ", gp " + str(gp))


fig, axes = plt.subplots(2, 1)
plot_objective(V, gp, axes[0])
plot_decision(V, gp, axes[1])

fig.tight_layout()
fig.set_size_inches(8, 7, forward=True)
plt.savefig('Fig1_Fig2_recover_V_gp.png')
